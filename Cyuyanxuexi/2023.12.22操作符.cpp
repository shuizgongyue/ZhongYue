#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//int main()
//{
//	// ====  右移操作符 只能作用于整数  ====
//	int a = 16;
//	//二进制表示为 10000
//	//00000000000000000000000000010000  32比特位 4字节
//	//00000000000000000000000000001000 移位后
//	//int b = a >> 3;
//	//右移操作符： 算术右移：右边丢弃，左边补原符号位
//	//逻辑右移：右边丢弃，左边补0；
//	//右移一位相当于除以2的效果。
//	//int c = -1;
//	//int b = c >> 1;
//	//证书的二进制表示有：原码 反码，补码。
//	//存储到内存的是补码。
//	//10000000000000000000000000000001  原码
//	//11111111111111111111111111111110  反码：符号位不变其他位按位取反
//	//11111111111111111111111111111111	补码：反码加一。
//	int c = -5;
//	int b = c >> 1;
//	//证书的二进制表示有：原码 反码，补码。
//	//存储到内存的是补码。
//	//10000000000000000000000000000101  原码
//	//11111111111111111111111111111010  反码：符号位不变其他位按位取反
//	//11111111111111111111111111111011	补码：反码加一。
//	//printf("%d", b);
//	//====  左移操作符  ====
//	//左边丢弃，右边补零
//	// ======  注意 移位操作符 不要移负数 该操作还未定义  ====
//	return 0;
//}
//int main()
//{
//	// & 按二进制位与		对应二进制位有一个为0则为0 两个同为1才为1
//	// | 按二进制位或		有1则为1 同时为0则为0
//	// ^ 按二进制位异或		对应二进制 相同为0 相异为1
//	int a = 3;
//	int b = 5;
//	//int c = a & b;
//	// a= 00000000000000000000000000000011
//	// b= 00000000000000000000000000000101
//	// c= 00000000000000000000000000000001
//	//int c = a | b;
//	// a= 00000000000000000000000000000011
//	// b= 00000000000000000000000000000101
//	// c= 00000000000000000000000000000111
//	int c = a ^ b;
//	// a= 00000000000000000000000000000011
//	// b= 00000000000000000000000000000101
//	// c= 00000000000000000000000000000110
//	printf("%d", c);
//	return 0;
//}
// 不创建临时变量 实现两个树的交换
//int main()
//{
//	int a, b;
//	a = 3;
//	b = 5;
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	a = a ^ b;
//	// a = 00000000000000000000000000000011
//	// b = 00000000000000000000000000000101
//	// a = 00000000000000000000000000000110    6
//	b = a ^ b;
//	// a = 00000000000000000000000000000110    6
//	// b = 00000000000000000000000000000101
//	// b = 00000000000000000000000000000011    3
//	a = a ^ b;
//	// a = 00000000000000000000000000000110    6
//	// b = 00000000000000000000000000000011    3
//	// a = 00000000000000000000000000000101	   5
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	return 0;
//}
// 求一个整数储存到内存中1个个数；
//int main()
//{
//	int num = 0,b=0;
//	scanf("%d", &num);
//	/*while (num)
//	{
//		if (num % 2 == 1)
//			b++;
//		num = num / 2;
//	}*/
//	//如果输入的是-1那么就会报错；
//	//不管是什么正负数最后都会放到4个字节32个比特位里面去
//	//利用移位操作符和 与 进行统计。
//	for (int i = 0; i < 32; i++)
//		if (1 == ((num >> i) & 1))
//			b++;
//	printf("%d", b);
//	return 0;
//}
// ~ 按二进制位取反；
//int main()
//{
//	int a = 0;
//	// 00000000000000000000000000000000 二进制表示
//	// 11111111111111111111111111111111 补码
//	// 11111111111111111111111111111110 反码
//	// 10000000000000000000000000000001 源码
//	int b = 10;
//	// 00000000000000000000000000001010
//	// 11111111111111111111111111110101 补码
//	// 11111111111111111111111111110100 反码
//	// 10000000000000000000000000001011 源码
//	printf("%d",~b); // = -1
//	return 0;
//}
void test1(int arr[])
{
	printf("%d\n", sizeof arr); //传过去个指针 一个指针大小为4/8个字节 根据平台选择
}
void test2(char ch[])
{
	printf("%d\n", sizeof ch);
}
/*int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof arr);
	printf("%d\n", sizeof ch);
	test1(arr);
	test2(ch);
	return 0;*/
//}   1 2 4 8 16 32 64
// || 逻辑 或 左边为真 右边就不用计算
// 
//int main()
//{
//	//int a = 1;
//	//int b = 2;
//	//int c = (a > b ? a : b);
//	////printf("%p", &c);
//	//printf("%d\n", sizeof(char*));
//	//printf("%d\n", sizeof(int*));
//	//printf("%d\n", sizeof(short*));
//	//printf("%d\n", sizeof(double*));
//	/*int a[10] = { 1 };
//	int* b = a;
//	for (int i = 0; i < 10; i++)
//	{
//		  b[i] = 2;
//	}
//	for (int j = 0; j < 10; j++)
//	{
//		printf("%d\n", a[j]);
//	}*/
//	/*int a[] = { 1,2,4,5,6,7,8,9 };
//	for (int i = 0; i < 8; i++)
//	{
//		a[i] = 10;
//		printf("%d\n", a[i]);
//	}*/
//	/*int a = 10;
//	int* b = &a;
//	*b = 30;
//	printf("%d", a);*/
//	int a[3][4] = { {1,2},{0},{4,6,8,10} };
//	printf("%d", a[1][2]);
//	return 0;
//	
//}
//	// & 按二进制位与		对应二进制位有一个为0则为0 两个同为1才为1
//	// | 按二进制位或		有1则为1 同时为0则为0
//	// ^ 按二进制位异或		对应二进制 相同为0 相异为1
//int main()
//{
//	//printf("%d", putchar(10));
//	//putchar(10);
//	/*int n=0;
//	n = (6 * 4, n + 6), n * 2;*/
//	int x = 10, y = 9;
//	int a, b, c;
//	a = (--x == y++) ? --x : ++y;
//	b = x++;
//	c = y;
//	/*printf("%d ", a);
//	printf("%d ", b);
//	printf("%d ", c);*/
//	char o[] = "abcdf";
//	char f[] = { 'a','b' };
//	printf("%d ", sizeof o);
//	printf("%d ", sizeof f);
//	return 0;
//}
void maopao(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz-1; i++)//确定比较的趟数
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)//一趟比较需要比较多少对
		{
			if (arr[j] > arr[j + 1])
			{
				int map = 0;
				map = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = map;
			}
		}
	}
}
//============  冒泡排序  从做到右一个一个的比较大小   =========== 
//int main()
//{
//	int arr[] = { 10,9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	maopao(arr,sz);
//	int i = 0;
//	for (i = 0; i <= sz-1; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//    ====   二分查找 ====== 
//    给定一个数组 接收一个用户输入的数字 在数组里面进行查早 找到了返回数组对应值的下标 否则返回NO
int erfen(int arr[],int sz,int inp)
{
	//确定左右下标
	int zuo = 0;
	int yu = sz - 1;

	while (zuo<=yu)
	{
		int zg = (zuo + yu) / 2;
		if (arr[zg] > inp)
		{
			yu = zg - 1;
		}
		else if (arr[zg] < inp)
		{
			zuo = zg + 1;
		}
		else
			return zg;
	}
	return -1;
}
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 };
//	//接受用户输入的数值
//	int inp = 0;
//	scanf_s("%d", &inp);
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int st=erfen(arr, sz,inp);
//	if (st != -1)
//	{
//		printf("找到了下标为：%d", st);
//	}
//	else
//	{
//		printf("NO");
//	}
//	return 0;
//}
//=========  判断一个数是不是润年
int RN(int a)
{
	if (a % 4 == 0 && a % 100 != 0 || a % 400 == 0)
		return 1;
	return 0;
}
//int main()
//{
//	int a = 0;
//	int b = 0;
//	for (b = 0; b <= 10000; b++)
//	{
//		printf("请输入年份: ");
//		scanf("%d", &a);
//		if (RN(a) != 0)
//		{
//			printf("是闰年\n");
//			//break;
//		}
//		else
//			printf("不是闰年\n");
//	}
//	return 0;
//}


















